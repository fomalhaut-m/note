----------------------------
> * rdb
> * aof
----------------------------

# 介绍
## Redis 持久化
* Redis 提供了不同级别的持久化方式:
    * RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储.
    * AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大.
    * 如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.
    * 你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.
# rdb(Redis DataBase)
## 定义
* Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到
一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。
整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能
如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方
式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。
## Fork
* fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）
数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程
## 配置
1. save
    * `save <seconds> <changes>`
    * 如果给定的秒数和给定的对数据库执行的写操作数量。
        ```
        save 900 1
        save 300 10
        save 60 10000
        
        900秒(15分钟)后，如果至少有一个键发生了变化
        300秒(5分钟)后，如果至少有10个键被更改
        60秒后，如果至少10000个键发生了变化
        ```
    * 如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以
2. `stop-writes-on-bgsave-error`
    * 如果配置成no，表示你不在乎数据不一致或者有其他的手段发现和控制
3. `rdbcompression`
    * 对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能
4. `rdbchecksum`
    * 在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能
5. `dbfilename`
    * 备份的文件名称
6. `dir`
    * 备份的文件地址
## 触发条件
* 命令:
    * save  
        * 立即保存,但是会阻塞所有进程
    * bgsave
        * 异步操作,不会阻塞所有进程 
    * flushall
        * 清空,后保存,但是没有意义  
    * shutdown
        * 关闭redis也会进行备份  
## 恢复
* 将备份文件拷回目录即可(与备份的文件名需要一致)
## 优势
* 适合大规模数据恢复
* 对数据完整性要求不高
## 劣势
* 在一定的时间做一次备份,意外关机,不会保存最后一次备份
* fork时,需要占用大量的内存
## 小结
