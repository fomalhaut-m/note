# 结构型模式（Structural Pattern）

## 适配器模式

适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。

这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。

将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

> 应用实例：\
> 1、读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡；\
> 2、美国电器110V，中国220V，就要有一个变压器将110V转化为220V。

## 装饰器模式

装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。

这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。

动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。

> 应用实例：\
> 1、孙悟空有72变，当他变成"庙宇"后，他的根本还是一只猴子，但是他又有了庙宇的功能；\
> 2、将一个形状装饰上不同的颜色，同时又不改变形状。

## 代理模式

在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。

在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。

为其他对象提供一种代理以控制对这个对象的访问。

> 应用实例：\
> 1、Windows里面的快捷方式；\
> 2、买火车票不一定在火车站买，也可以去代售点；\
> 3、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制；\
> 4、Spring AOP。\
>

* 注意事项：
  1. 和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。
  2. 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。

## 外观模式

外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。

这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。

为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

> 应用实例： 去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。

## 桥接模式

桥接模式（Bridge Pattern）是用于把抽象化与实现化解耦，使得二者可以独立变化。它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。

这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。

将抽象部分与实现部分分离，使它们都可以独立的变化。

又称为柄体（Handle and Body）模式或接口（Interface）模式。

> 应用实例：\
> 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择；\
> 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的；\
> 3、如果要绘制不同的颜色，如红色、绿色、蓝色的矩形、圆形、椭圆、正方形，我们需要根据实际需要对形状和颜色进行组合，那么颜色、形状就是抽象部分，组合后的就是实现部分。\
>

注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。

## 组合模式

组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。

将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

> 应用实例：\
> 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。\
> 2、在JAVAAWT和SWING中，对于Button和Checkbox是树叶，Container是树枝。

## 享元模式

享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。

享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。

> 使用场景：\
> 1、系统有大量相似对象。\
> 2、需要缓冲池的场景。

注意事项：

1. 注意划分外部状态和内部状态，否则可能会引起线程安全问题。
2. 这些类必须有一个工厂对象加以控制。
